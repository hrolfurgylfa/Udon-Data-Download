// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at https://mozilla.org/MPL/2.0/.

package main

import (
	"fmt"
	"io"
	"os"
	"strings"
	"text/template"
	"unicode"

	"google.golang.org/protobuf/proto"
	"google.golang.org/protobuf/types/descriptorpb"
	"google.golang.org/protobuf/types/pluginpb"
)

type FieldType struct {
	WireType    uint8
	NeedsLength bool
	USharpType  uSharpType
}

type FieldData struct {
	Number   int32
	Name     SnakeCaseString
	Type     FieldType
	Multiple bool
}

type MessageData struct {
	Name   string
	Fields []FieldData
}

type uSharpType int

const (
	uSharpTypeULong uSharpType = iota
	uSharpTypeString
)

var funcMap = template.FuncMap{
	"uSharpTypeULong":  func() uSharpType { return uSharpTypeULong },
	"uSharpTypeString": func() uSharpType { return uSharpTypeString },
}

func (s uSharpType) CSharpType() string {
	strings := [...]string{"ulong", "string"}

	if s < uSharpTypeULong || s > uSharpTypeString {
		return "Unknown"
	}

	return strings[s]
}

func (s uSharpType) UdonTokenAccessor() string {
	strings := [...]string{"ULong", "String"}

	if s < uSharpTypeULong || s > uSharpTypeString {
		return "Unknown"
	}

	return strings[s]
}

func ToTitleCase(str string) string {
	if len(str) == 0 {
		return ""
	}

	r := []rune(str)
	r[0] = unicode.ToUpper(r[0])
	return string(r)
}

type SnakeCaseString string

func (s SnakeCaseString) String() string {
	return string(s)
}

func (s SnakeCaseString) CamelCase() string {
	ret := strings.Builder{}
	ret.Grow(len(s))
	runes := []rune(s)
	for i := 0; i < len(runes); i++ {
		if runes[i] == '_' {
			i++
			if i < len(runes) {
				ret.WriteRune(unicode.ToUpper(runes[i]))
			}
		} else {
			ret.WriteRune(runes[i])
		}
	}
	return ret.String()
}

func (s SnakeCaseString) PascalCase() string {
	str := s.CamelCase()
	if len(str) == 0 {
		return ""
	}

	r := []rune(s)
	r[0] = unicode.ToUpper(r[0])
	return string(r)
}

func WriteTemplate(writer io.Writer, data any, name string) error {
	tmpl, err := template.New("message.tmpl").Funcs(funcMap).ParseFiles("templates/message.tmpl")
	if err != nil {
		return err
	}
	err = tmpl.Execute(writer, data)
	if err != nil {
		return err
	}
	_, err = writer.Write([]byte("\r\n"))
	return err
}

func WriteMessage(fileContent *strings.Builder, msg *descriptorpb.DescriptorProto) error {
	W := func(str string) {
		fileContent.Grow(len(str) + 1)
		_, _ = fileContent.WriteString(str)
		_, _ = fileContent.WriteString("\r\n")
	}

	W("// SPDX-License-Identifier: MIT")
	W("// Code generated by UdonDataDownload. DO NOT EDIT.")
	W("")
	W("using UnityEngine;")
	W("using VRC.SDK3.Data;")
	W("")
	W("namespace Hroi.UdonDataDownload.Generated")
	W("{")
	msgData := MessageData{Name: msg.GetName()}
	for _, field := range msg.GetField() {
		opts := field.GetOptions()

		if opts.GetPacked() {
			return fmt.Errorf(
				"packed not supported for UdonSharp, please add [packed=false] on field %v",
				field.GetName(),
			)
		}

		ft := FieldType{}
		switch field.GetType() {
		case descriptorpb.FieldDescriptorProto_TYPE_UINT64:
			ft = FieldType{USharpType: uSharpTypeULong}
		case descriptorpb.FieldDescriptorProto_TYPE_STRING:
			ft = FieldType{USharpType: uSharpTypeString, WireType: 2, NeedsLength: true}
		default:
			return fmt.Errorf(
				"protobuf type %v on %v not supported yet",
				field.GetType().String(),
				field.GetName(),
			)
		}

		ft.USharpType.CSharpType()
		msgData.Fields = append(msgData.Fields, FieldData{
			Type:     ft,
			Name:     SnakeCaseString(field.GetName()),
			Number:   field.GetNumber(),
			Multiple: field.GetLabel() == descriptorpb.FieldDescriptorProto_LABEL_REPEATED,
		})
	}
	err := WriteTemplate(fileContent, msgData, "templates/message.tmpl")
	if err != nil {
		return err
	}
	W("}")
	return nil
}

func main() {
	bytes, err := io.ReadAll(os.Stdin)
	if err != nil {
		panic(err)
	}

	req := &pluginpb.CodeGeneratorRequest{}
	proto.Unmarshal(bytes, req)

	files := make([]*pluginpb.CodeGeneratorResponse_File, 0)
	for _, proto_file := range req.GetProtoFile() {
		// Make the new file name for the protobuf Udon# file
		proto_name := proto_file.GetName()
		fileName, found := strings.CutSuffix(proto_name, ".proto")
		if !found {
			panic(err)
		}
		fileName += ".pb.cs"

		fileContent := strings.Builder{}
		for _, msg := range proto_file.GetMessageType() {
			err := WriteMessage(&fileContent, msg)
			if err != nil {
				panic(err)
			}
		}

		fileContentStr := fileContent.String()
		files = append(files, &pluginpb.CodeGeneratorResponse_File{
			Name:    &fileName,
			Content: &fileContentStr,
		})
	}

	res := &pluginpb.CodeGeneratorResponse{File: files}
	res_bytes, err := proto.Marshal(res)
	if err != nil {
		panic(err)
	}

	os.Stdout.Write(res_bytes)
}

// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at https://mozilla.org/MPL/2.0/.

package main

import (
	"fmt"
	"io"
	"os"
	"strings"
	"text/template"
	"unicode"

	"google.golang.org/protobuf/proto"
	"google.golang.org/protobuf/types/descriptorpb"
	"google.golang.org/protobuf/types/pluginpb"
)

type FieldType struct {
	WireType      uint8
	NeedsLength   bool
	Enum          uSharpType
	CSharpTypeStr string
}

type FieldData struct {
	Number   int32
	Name     SnakeCaseString
	Type     FieldType
	Multiple bool
}

type MessageData struct {
	Name   string
	Fields []FieldData
}

type uSharpType int

const (
	uSharpTypeULong uSharpType = iota
	uSharpTypeString
	uSharpTypeMessage
)

var funcMap = template.FuncMap{
	"uSharpTypeULong":   func() uSharpType { return uSharpTypeULong },
	"uSharpTypeString":  func() uSharpType { return uSharpTypeString },
	"uSharpTypeMessage": func() uSharpType { return uSharpTypeMessage },
}

func (ft FieldType) CSharpType() string {
	switch ft.Enum {
	case uSharpTypeULong:
		return "ulong"
	case uSharpTypeString:
		return "string"
	case uSharpTypeMessage:
		return "DataDictionary"
	default:
		panic(fmt.Sprintf("Unknown enum value of uSharpType %v", ft.Enum))
	}
}

func (ft FieldType) UdonTokenAccessor() string {
	strings := [...]string{"ULong", "String", "DataDictionary"}
	return strings[ft.Enum]
}

func ToTitleCase(str string) string {
	if len(str) == 0 {
		return ""
	}

	r := []rune(str)
	r[0] = unicode.ToUpper(r[0])
	return string(r)
}

type SnakeCaseString string

func (s SnakeCaseString) String() string {
	return string(s)
}

func (s SnakeCaseString) CamelCase() string {
	ret := strings.Builder{}
	ret.Grow(len(s))
	runes := []rune(s)
	for i := 0; i < len(runes); i++ {
		if runes[i] == '_' {
			i++
			if i < len(runes) {
				ret.WriteRune(unicode.ToUpper(runes[i]))
			}
		} else {
			ret.WriteRune(runes[i])
		}
	}
	return ret.String()
}

func (s SnakeCaseString) PascalCase() string {
	str := s.CamelCase()
	if len(str) == 0 {
		return ""
	}

	r := []rune(s)
	r[0] = unicode.ToUpper(r[0])
	return string(r)
}

func WriteTemplate(writer io.Writer, data any, name string) error {
	tmpl, err := template.New("message.tmpl").Funcs(funcMap).ParseFiles("templates/message.tmpl")
	if err != nil {
		return err
	}
	err = tmpl.Execute(writer, data)
	if err != nil {
		return err
	}
	_, err = writer.Write([]byte("\r\n"))
	return err
}

func WriteMessage(fileContent *strings.Builder, msg *descriptorpb.DescriptorProto) error {
	msgData := MessageData{Name: msg.GetName()}
	for _, field := range msg.GetField() {
		opts := field.GetOptions()

		if opts.GetPacked() {
			return fmt.Errorf(
				"packed not supported for UdonSharp, please add [packed=false] on field %v",
				field.GetName(),
			)
		}

		ft := FieldType{}
		switch field.GetType() {
		case descriptorpb.FieldDescriptorProto_TYPE_UINT64:
			ft = FieldType{Enum: uSharpTypeULong}
		case descriptorpb.FieldDescriptorProto_TYPE_STRING:
			ft = FieldType{Enum: uSharpTypeString, WireType: 2, NeedsLength: true}
		case descriptorpb.FieldDescriptorProto_TYPE_MESSAGE:
			typeName := field.GetTypeName()
			if !strings.HasPrefix(typeName, ".") {
				return fmt.Errorf("failed to find type %v, only local scope messages are supported, you can't import them from elsewhere yet", typeName)
			}
			ft = FieldType{Enum: uSharpTypeMessage, WireType: 2, NeedsLength: true, CSharpTypeStr: typeName[1:]}
		default:
			return fmt.Errorf(
				"protobuf type \"%v\" on %v.%v not supported yet",
				field.GetType().String(),
				msg.GetName(),
				field.GetName(),
			)
		}

		msgData.Fields = append(msgData.Fields, FieldData{
			Type:     ft,
			Name:     SnakeCaseString(field.GetName()),
			Number:   field.GetNumber(),
			Multiple: field.GetLabel() == descriptorpb.FieldDescriptorProto_LABEL_REPEATED,
		})
	}
	return WriteTemplate(fileContent, msgData, "templates/message.tmpl")
}

func main() {
	bytes, err := io.ReadAll(os.Stdin)
	if err != nil {
		panic(err)
	}

	req := &pluginpb.CodeGeneratorRequest{}
	proto.Unmarshal(bytes, req)

	files := make([]*pluginpb.CodeGeneratorResponse_File, 0)
	for _, proto_file := range req.GetProtoFile() {
		// Make the new file name for the protobuf Udon# file
		proto_name := proto_file.GetName()
		fileName, found := strings.CutSuffix(proto_name, ".proto")
		if !found {
			panic(err)
		}
		fileName += ".pb.cs"

		fileContent := strings.Builder{}
		W := func(str string) {
			fileContent.Grow(len(str) + 1)
			_, _ = fileContent.WriteString(str)
			_, _ = fileContent.WriteString("\r\n")
		}

		W("// SPDX-License-Identifier: MIT")
		W("// Code generated by UdonDataDownload. DO NOT EDIT.")
		W("")
		W("using UnityEngine;")
		W("using VRC.SDK3.Data;")
		W("")
		W("namespace Hroi.UdonDataDownload.Generated")
		W("{")

		for _, msg := range proto_file.GetMessageType() {
			err := WriteMessage(&fileContent, msg)
			if err != nil {
				panic(err)
			}
		}

		W("}")

		fileContentStr := fileContent.String()
		files = append(files, &pluginpb.CodeGeneratorResponse_File{
			Name:    &fileName,
			Content: &fileContentStr,
		})
	}

	res := &pluginpb.CodeGeneratorResponse{File: files}
	res_bytes, err := proto.Marshal(res)
	if err != nil {
		panic(err)
	}

	os.Stdout.Write(res_bytes)
}
